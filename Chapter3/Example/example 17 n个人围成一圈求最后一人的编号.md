### 例17 游戏问题
12个小朋友手拉手站成一个圈，从某一个小朋友开始报数，报到7的那个小朋友退出到圈外，然后他的下一位重新报“1”。这样继续下去，直到最后只剩下一个小朋友。求解这个小朋友原来站在什么位置上。
### 问题分析
为了算法的通用性，算法允许对游戏的总人数，报数的起点，退出圈外的报数点任意输入。其中n表示游戏的总人数，k表示开始报数人的编号及状态数组的下标变量，m表示退出圈外人的报数点，即报m的人出队，p表示已退出圈外的人数。
### 算法设计1
```c
#include<stdio.h>
int main()
{
    int i, n, k, m, p, a[100];
    printf("input number of game: ");
    scanf_s("%d", &n);              //输入游戏总人数 n
    printf("input serial number of game start: ");
    scanf_s("%d", &k);              //输入游戏开始报数编号 k
    printf("input number of out_ring: ");
    scanf_s("%d", &m);              //输入退出圈外的报数点 m
    printf("Wash out: ");
    for (i = 1;i <= n;i++)
        a[i] = 1;                   //表示编号为i的人当前未出队
    
    p = 0;                          //开始游戏前，退出圈外人数为0
    k--;                            //编号为k的人报数为1，则编号为k-1的报数为0
    while (p < n-1)                 //由于p初始为零，当出队人数p等于总人数n-2时，已循环了n-1次，停止循环
    {
        i = 0;                      //由于k=k-1，所以i=1-1=0
        while (i < m)               //当报数到m-1时，停止报数
        {
            k++;                    //k递增到原本的数，从1开始报数
            if (k > n) k = 1;       //n号报完就该1号报数
            i = i + a[k];           //若a[k]=1，则表示当前位置的人未出圈，下一位继续报数+1
                                    //若a[k]=0，则表示当前位置的人已出圈，下一位继续报数不变
        }
        a[k] = 0;                   //表示当前编号为k的人出圈
        printf("%d ", k);
        p++;
    }
    printf("\nThe last one: ");
    for (i = 1;i <= n;i++)
        if (a[i] == 1)
            printf("%d", i);
    printf("\n");
    return 0;
}
```